<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>node-mutation.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="https://code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <li class="nav-link nav-home-link"><a href="index.html">Home</a></li><li class="nav-heading">Classes</li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="ConflictActionError.html">ConflictActionError</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="NodeMutation.html">NodeMutation</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="NodeMutation.html#.configure">configure</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="NodeMutation.html#append">append</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="NodeMutation.html#delete">delete</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="NodeMutation.html#insert">insert</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="NodeMutation.html#noop">noop</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="NodeMutation.html#prepend">prepend</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="NodeMutation.html#process">process</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="NodeMutation.html#remove">remove</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="NodeMutation.html#replace">replace</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="NodeMutation.html#replaceWith">replaceWith</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="NodeMutation.html#test">test</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="NotSupportedError.html">NotSupportedError</a></span></li><li class="nav-heading"><a href="global.html">Globals</a></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#getAdapter">getAdapter</a></span></li>
</nav>

<div id="main">
    
    <h1 class="page-title">node-mutation.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>"use strict";
var __importDefault = (this &amp;&amp; this.__importDefault) || function (mod) {
    return (mod &amp;&amp; mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const typescript_adapter_1 = __importDefault(require("./typescript-adapter"));
const strategy_1 = __importDefault(require("./strategy"));
const action_1 = require("./action");
const error_1 = require("./error");
const debug_1 = __importDefault(require("debug"));
class NodeMutation {
    /**
     * Configure NodeMutation
     * @static
     * @param options {Object}
     * @param options.adapter {Adapter} - adapter, default is TypescriptAdapter
     * @param options.strategy {Strategy} - strategy, default is Strategy.THROW_ERROR
     * @param options.tabWidth {Number} - tab width, default is 2
     */
    static configure(options) {
        if (options.adapter) {
            this.adapter = options.adapter;
        }
        if (options.strategy) {
            this.strategy = options.strategy;
        }
        if (options.tabWidth) {
            this.tabWidth = options.tabWidth;
        }
    }
    static getAdapter() {
        if (!this.adapter) {
            this.adapter = new typescript_adapter_1.default();
        }
        return this.adapter;
    }
    /**
     * Initialize a NodeMutation
     * @param source {string} - file source.
     */
    constructor(source) {
        this.source = source;
        this.actions = [];
    }
    /**
     * Append code to the ast node.
     * @param node {T} - ast node
     * @param code {string} - new code to append
     * @example
     * source code of the ast node is
     * ```
     * class FooBar {
     *   foo() {}
     * }
     * ```
     * then we call
     * ```
     * mutation.append(node, "bar() {}");
     * ```
     * the source code will be rewritten to
     * ```
     * class FooBar {
     *   foo() {}
     *   bar() {}
     * }
     * ```
     */
    append(node, code) {
        this.actions.push(new action_1.AppendAction(node, code).process());
    }
    /**
     * Delete source code of the child ast node
     * @param node {T} - current ast node
     * @param selectors {string|string[]} - selectors to find chid ast nodes
     * @example
     * source code of the ast node is
     * ```
     * this.foo.bind(this)
     * ```
     * then we call
     * ```
     * mutation.delete(["expression.expression.dot", "expression.expression.name", "expression.arguments"])
     * ```
     * the source code will be rewritten to
     * ```
     * this.foo
     * ```
     */
    delete(node, selectors) {
        this.actions.push(new action_1.DeleteAction(node, selectors).process());
    }
    /**
     * Insert code to the ast node.
     * @param node {T} - ast node
     * @param code {string} - new code to insert
     * @param options {Object}
     * @params options.at {string} - position to insert, "beginning" or "end", "end" is by default
     * @params options.to {string} - selector to find the child ast node
     * @example
     * source code of the ast node is
     * ```
     * this.foo
     * ```
     * then we call
     * ```
     * mutation.insert(node, "::", { at: "beginning" });
     * ```
     * the source code will be rewritten to
     * ```
     * ::this.foo
     * ```
     * if we call
     * ```
     * mutation.insert(node, ".bar", { to: "expression.expression" })
     * ```
     * the source code will be rewritten to
     * ```
     * this.foo.bar
     * ```
     */
    insert(node, code, options) {
        this.actions.push(new action_1.InsertAction(node, code, options).process());
    }
    /**
     * No operation.
     * @param node {T} - ast node
     */
    noop(node) {
        this.actions.push(new action_1.NoopAction(node).process());
    }
    /**
     * Prepend code to the ast node.
     * @param node {T} - ast node
     * @param code {string} - new code to prepend
     * @example
     * source code of the ast node is
     * ```
     * class FooBar {
     *   foo() {}
     * }
     * ```
     * then we call
     * ```
     * mutation.prepend(node, "bar() {}");
     * ```
     * the source code will be rewritten to
     * ```
     * class FooBar {
     *   bar() {}
     *   foo() {}
     * }
     * ```
     */
    prepend(node, code) {
        this.actions.push(new action_1.PrependAction(node, code).process());
    }
    /**
     * Remove source code of the ast node
     * @param node {T} - ast node
     * @example
     * source code of the ast node is
     * ```
     * this.foo.bind(this)
     * ```
     * then we call
     * ```
     * mutation.remove()
     * ```
     * the source code will be completely removed
     */
    remove(node) {
        this.actions.push(new action_1.RemoveAction(node).process());
    }
    /**
     * Replace child node of the ast node with new code
     * @param node {T} - current ast node
     * @param selectors {string|string[]} - selectors to find chid ast nodes
     * @param options {Object}
     * @params options.with {string} - new code to replace
     * @example
     * source code of the ast node is
     * ```
     * class FooBar {}
     * ```
     * then we call
     * ```
     * mutation.replace(node, "name", { with: "Synvert" });
     * ```
     * the source code will be rewritten to
     * ```
     * class Synvert {}
     * ```
     */
    replace(node, selectors, options) {
        this.actions.push(new action_1.ReplaceAction(node, selectors, options).process());
    }
    /**
     * Replace the ast node with new code
     * @param node {T} - ast node
     * @params code {string} - new code to replace
     * @example
     * source code of the ast node is
     * ```
     * !!foobar
     * ```
     * then we call
     * ```
     * mutation.replaceWith(node, "Boolean({{expression.operand.operand}})");
     * ```
     * the source code will be rewritten to
     * ```
     * Boolean(foobar)
     * ```
     */
    replaceWith(node, code, options = { autoIndent: true }) {
        this.actions.push(new action_1.ReplaceWithAction(node, code, options).process());
    }
    /**
     * Rewrite the source code based on all actions.
     *
     * If there's an action range conflict,
     * it will raise a ConflictActionError if strategy is set to THROW_ERROR,
     * it will process all non conflicted actions and return `{ conflicted: true }`
     * @returns {ProcessResult} if actions are conflicted and the new source.
     */
    process() {
        if (this.actions.length == 0) {
            return { affected: false, conflicted: false };
        }
        let conflictActions = [];
        this.actions.sort(this.compareActions);
        conflictActions = this.getConflictActions();
        if (conflictActions.length > 0 &amp;&amp; this.isStrategry(strategy_1.default.THROW_ERROR)) {
            throw new error_1.ConflictActionError();
        }
        let newSource = this.source;
        this.actions.reverse().forEach((action) => {
            if (typeof action.newCode !== "undefined") {
                newSource =
                    newSource.slice(0, action.start) +
                        action.newCode +
                        newSource.slice(action.end);
            }
        });
        return {
            affected: true,
            conflicted: conflictActions.length !== 0,
            newSource
        };
    }
    /**
     * Return the actions.
     *
     * If there's an action range conflict,
     * it will raise a ConflictActionError if strategy is set to THROW_ERROR,
     * it will process all non conflicted actions and return `{ conflicted: true }`
     * @returns {ProcessResult} if actions are conflicted and the actions
     */
    test() {
        if (this.actions.length == 0) {
            return { affected: false, conflicted: false, actions: [] };
        }
        let conflictActions = [];
        this.actions.sort(this.compareActions);
        conflictActions = this.getConflictActions();
        if (conflictActions.length > 0 &amp;&amp; this.isStrategry(strategy_1.default.THROW_ERROR)) {
            throw new error_1.ConflictActionError();
        }
        return { affected: true, conflicted: conflictActions.length !== 0, actions: this.actions };
    }
    /**
     * Action sort function.
     * @private
     * @param {Action} actionA
     * @param {Action} actionB
     * @returns {number} returns 1 if actionA goes before actionB, -1 if actionA goes after actionB
     */
    compareActions(actionA, actionB) {
        if (actionA.start > actionB.start)
            return 1;
        if (actionA.start &lt; actionB.start)
            return -1;
        if (actionA.end > actionB.end)
            return 1;
        if (actionA.end &lt; actionB.end)
            return -1;
        return 0;
    }
    /**
     * Get conflict actions.
     * @private
     * @returns {Action[]} conflict actions
     */
    getConflictActions() {
        let i = this.actions.length - 1;
        let j = i - 1;
        const conflictActions = [];
        if (i &lt; 0)
            return [];
        let beginPos = this.actions[i].start;
        let endPos = this.actions[i].end;
        while (j > -1) {
            // if we have two insert actions at same position.
            const samePosition = beginPos == this.actions[j].start &amp;&amp; beginPos == endPos &amp;&amp; this.actions[j].start == this.actions[j].end;
            // if we have two actions with overlapped range.
            const overlappedPosition = beginPos &lt; this.actions[j].end;
            if ((!this.isStrategry(strategy_1.default.ALLOW_INSERT_AT_SAME_POSITION) &amp;&amp; samePosition) || overlappedPosition) {
                conflictActions.push(this.actions.splice(j, 1)[0]);
            }
            else {
                i = j;
                beginPos = this.actions[i].start;
                endPos = this.actions[i].end;
            }
            j--;
        }
        conflictActions.forEach(conflictAction => {
            (0, debug_1.default)("node-mutation")(`${conflictAction.constructor.name}[${conflictAction.start}-${conflictAction.end}]:${conflictAction.newCode}`);
        });
        return conflictActions;
    }
    isStrategry(strategy) {
        return !!NodeMutation.strategy &amp;&amp; (NodeMutation.strategy &amp; strategy) === strategy;
    }
}
NodeMutation.strategy = strategy_1.default.THROW_ERROR;
NodeMutation.tabWidth = 2;
exports.default = NodeMutation;
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.7</a> on Wed Feb 08 2023 12:25:20 GMT+0000 (Coordinated Universal Time) using the Minami theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
